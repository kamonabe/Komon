---
rule-id: spec-quality-assurance
priority: high
applies-to:
- spec-creation
- implementation-start
triggers:
- spec-complete
- implementation-start
description: Spec品質保証と検証スクリプト実行ルール
---

# Spec品質保証ルール

## 基本方針

Komonプロジェクトでは、**ローカルで確実に品質を作り込み、CI/CDで公開品質を証明する**方針を採用しています。

Komonはシンプル軽量なツールであり、検証スクリプトも軽量なため、冗長性を気にせずローカルとCI/CDの両方でしっかり検証を行います。

## 検証スクリプト

### 1. `scripts/validate_specs.py`（構造検証）
**チェック項目**:
- ✅ **エラー**: Front Matterの必須フィールド（title, feature, status, created, updated）
- ✅ **エラー**: 日付フォーマット（YYYY-MM-DD）
- ✅ **エラー**: 必須セクションの存在
- ✅ **エラー**: タスクが1つも定義されていない
- ⚠️ **警告**: 受入基準の数（3個以上推奨）
- ⚠️ **警告**: WHEN-THEN形式の使用
- ⚠️ **警告**: 正確性プロパティの数（3個以上推奨）
- ⚠️ **警告**: プロパティの検証対象（AC-XXX）記載
- ⚠️ **警告**: タスクの要件（AC-XXX）記載

### 2. `scripts/check_spec_consistency.py`（一貫性検証）

**チェック項目**:
- ✅ **エラー**: 3ファイル間のfeature名一致
- ✅ **エラー**: 存在しない受入基準の参照
- ⚠️ **警告**: プロパティが受入基準を参照しているか
- ⚠️ **警告**: タスクが受入基準をカバーしているか

## 警告の扱い（ハイブリッド方式）

### 修正必須の警告（実装開始前に必ず対応）

以下の警告は**トレーサビリティ**に関わるため、実装開始前に必ず修正します：

- ❌ **タスクが受入基準をカバーしていない**
  - 全ての受入基準（AC-XXX）がタスクで言及されている必要がある
  - カバーされていない受入基準がある場合は、タスクを追加または修正

- ❌ **プロパティが受入基準を参照していない**
  - 全ての正確性プロパティが、どの受入基準を検証するか明記する必要がある
  - 参照されていない受入基準がある場合は、プロパティを追加または修正

### 許容可能な警告（柔軟に判断）

以下の警告は**推奨事項**であり、機能の規模に応じて柔軟に判断します：

- ✅ **受入基準が3個未満**
  - 小さな機能なら2個でもOK
  - ただし、最低1個は必要

- ✅ **正確性プロパティが3個未満**
  - シンプルな機能なら2個でもOK
  - ただし、最低1個は必要

- ✅ **WHEN-THEN形式がない**
  - 他の形式で明確に記述されていればOK

- ✅ **タスクの50%未満に要件記載がない**
  - 主要なタスクに記載があればOK

## 🚨 Kiroへの厳格な指示：Spec検証の自動実行

### 基本原則

**Kiroは、Spec作成完了時と実装開始直前に、必ず検証スクリプトを自動実行します。**

ユーザーに「検証しますか？」と聞かず、**自動的に実行**してください。

### 実行タイミング

#### タイミング1: Spec完成時（必須・自動実行）

**トリガー**: Kiroが`requirements.yml`, `design.yml`, `tasks.yml`の3ファイルを作成完了した時点

**Kiroの動作**:
1. **宣言**: 「Spec検証を実行します」
2. **自動実行**:
   ```bash
   python scripts/validate_specs.py
   python scripts/check_spec_consistency.py
   ```
3. **結果を報告**:
   - エラー0件、警告0件 → 「✅ Spec検証が完了しました。問題ありません」
   - エラーあり → 「❌ エラーが見つかりました」+ 修正提案
   - トレーサビリティ警告あり → 「⚠️ 修正が必要な警告があります」+ 修正提案
   - 推奨事項の警告のみ → 「⚠️ 推奨事項の警告があります」+ ユーザーに判断を委ねる

**重要**: ユーザーに「検証しますか？」と聞かない。自動実行する。

```bash
# Kiroが自動実行
python scripts/validate_specs.py
python scripts/check_spec_consistency.py
```

**検証結果の対応**:
- ✅ **エラーなし**: ユーザーに報告、内容確認を依頼
- ❌ **エラーあり**: 自動修正または修正方針を提示
- ⚠️ **警告あり**: 
  - トレーサビリティ系: 修正を提案
  - 推奨事項: ユーザーに判断を委ねる

#### タイミング2: 実装開始直前（必須・自動実行）

**トリガー**: ユーザーが「実装開始しよう」「TASK-XXXを進めよう」と言った時点

**Kiroの動作**:
1. **ブランチ確認**（既存ルール通り）:
   ```bash
   git branch
   ```
2. **Spec再検証を自動実行**:
   ```bash
   python scripts/validate_specs.py
   python scripts/check_spec_consistency.py
   ```
3. **検証結果に応じて対応**:
   - ✅ **問題なし**: 実装開始
   - ❌ **エラーあり**: 実装を開始せず、修正を優先
   - ⚠️ **トレーサビリティ警告あり**: 実装を開始せず、修正を提案
   - ⚠️ **推奨事項の警告のみ**: ユーザーに確認
     ```
     ⚠️  推奨事項の警告があります：
     - 受入基準が2個しかありません（推奨: 3個以上）
     
     このまま実装を開始しますか？
     それとも受入基準を追加しますか？
     ```

**重要**: 実装開始前に必ず再検証する。スキップしない。

#### タイミング3: Spec修正後（推奨・手動実行）

**トリガー**: 実装中にSpecを修正した場合

**Kiroの動作**:
- 「Specを修正しました。検証スクリプトを実行することを推奨します」
- ユーザーが希望すれば実行

**重要**: このタイミングは必須ではない。ユーザーの判断に委ねる。

## CI/CDとの使い分け

### ローカル検証（開発品質の担保）

**目的**: 開発段階で品質を作り込む

**実行内容**:
- 構造検証（`validate_specs.py`）
- 一貫性検証（`check_spec_consistency.py`）

**実行者**: Kiro（自動）

**タイミング**: Spec完成時 + 実装開始直前

### CI/CD検証（公開品質の証明）

**目的**: 公開されたコードの品質を第三者に証明する

**実行内容**:
- 構造検証（`validate_specs.py`）
- 一貫性検証（`check_spec_consistency.py`）
- リンク切れチェック
- 必須ドキュメント存在確認

**実行者**: GitHub Actions（自動）

**タイミング**: Spec/ドキュメント変更時のpush/PR

**冗長性について**: Komonはシンプル軽量なツールなので、検証スクリプトも数秒で完了します。ローカルとCI/CDの両方で実行しても問題ありません。

## 🎯 Kiroへの厳格な指示：実行フロー

### フロー1: Spec作成完了時（自動実行）

#### ステップ1: 完了確認
- `requirements.yml`, `design.yml`, `tasks.yml`の3ファイルが作成完了

#### ステップ2: 宣言
```
✅ Spec作成が完了しました。検証スクリプトを実行します。
```

#### ステップ3: 自動実行（ユーザーに聞かない）
```bash
python scripts/validate_specs.py
python scripts/check_spec_consistency.py
```

#### ステップ4: 結果を報告
```
✅ Spec検証が完了しました

【構造検証】
- エラー: 0件
- 警告: 2件
  • log-tail-excerpt/design.yml: 正確性プロパティが2個しかありません（推奨: 3個以上）
  • log-tail-excerpt/tasks.yml: 一部のタスクに要件（AC-XXX）が記載されていません

【一貫性検証】
- エラー: 0件
- 警告: 0件

推奨事項の警告のみなので、このまま進めても問題ありません。
内容を確認してください。
```

#### ステップ5: エラー対応
- **エラー0件**: 次のステップへ
- **エラーあり**: 修正提案 → ユーザー判断
- **トレーサビリティ警告**: 修正提案 → ユーザー判断
- **推奨事項の警告のみ**: ユーザーに報告（修正は任意）

### フロー2: 実装開始直前（自動実行）

#### ステップ1: トリガー検知
- ユーザーが「TASK-XXXを実装しよう」「実装を開始して」と言った

#### ステップ2: ブランチ確認（既存ルール）
```bash
git branch
```

#### ステップ3: Spec再検証を自動実行
```
実装開始前にSpec検証を実行します。
```

```bash
python scripts/validate_specs.py
python scripts/check_spec_consistency.py
```

#### ステップ4: 検証結果に応じて対応
- ✅ **問題なし**: 「✅ Spec検証完了。実装を開始します」→ 実装開始
- ❌ **エラーあり**: 「❌ エラーがあります。修正してから実装を開始してください」→ 実装を開始しない
- ⚠️ **トレーサビリティ警告**: 「⚠️ 修正が必要な警告があります」→ 修正提案 → 実装を開始しない
- ⚠️ **推奨事項の警告のみ**: ユーザーに確認
  ```
  ⚠️  推奨事項の警告があります：
  - 受入基準が2個しかありません（推奨: 3個以上）
  
  このまま実装を開始しますか？（y/n）
  ```

### 📋 Kiroのチェックリスト

#### Spec作成完了時
- [ ] 3ファイル（requirements.yml, design.yml, tasks.yml）が作成完了
- [ ] 「Spec検証を実行します」と宣言した
- [ ] `validate_specs.py`を自動実行した
- [ ] `check_spec_consistency.py`を自動実行した
- [ ] 検証結果をユーザーに報告した
- [ ] エラーがある場合は修正提案をした

#### 実装開始直前
- [ ] ユーザーが「実装開始」を指示した
- [ ] `git branch`でブランチを確認した
- [ ] 「Spec検証を実行します」と宣言した
- [ ] `validate_specs.py`を自動実行した
- [ ] `check_spec_consistency.py`を自動実行した
- [ ] 検証結果に応じて対応した：
  - [ ] 問題なし → 実装開始
  - [ ] エラーあり → 実装を開始せず、修正を優先
  - [ ] トレーサビリティ警告 → 実装を開始せず、修正を提案
  - [ ] 推奨事項の警告のみ → ユーザーに確認
- [ ] 上記が全て完了してから実装を開始した

#### 禁止事項
- [ ] ユーザーに「検証しますか？」と聞いた（自動実行すべき）
- [ ] 検証スクリプトをスキップした
- [ ] エラーがあるのに実装を開始した

## トラブルシューティング

### Q: 検証スクリプトが失敗する

**A**: 以下を確認してください：
```bash
# Pythonバージョン確認（3.10+以上）
python --version

# 依存パッケージインストール
pip install pyyaml

# スクリプトの実行権限確認
chmod +x scripts/validate_specs.py
chmod +x scripts/check_spec_consistency.py
```

### Q: 警告が多すぎて判断に困る

**A**: まずトレーサビリティ系の警告を優先的に修正してください：
1. タスクが受入基準をカバーしているか
2. プロパティが受入基準を参照しているか

推奨事項の警告は、機能の規模に応じて柔軟に判断してOKです。

### Q: CI/CDで失敗したがローカルでは成功する

**A**: 以下の可能性があります：
- ファイルがコミットされていない
- 改行コードの違い（CRLF vs LF）
- Pythonバージョンの違い

ローカルで再度確認してください：
```bash
git status  # コミット漏れ確認
python scripts/validate_specs.py
python scripts/check_spec_consistency.py
```

## レジリエンス設計の検討

### 基本方針

**「検討したけど採用しない」を明文化することが、設計として正しい**

理由：
- 検討漏れと意図的な非採用は全く違う
- 将来の自分や他の開発者への説明責任
- システムの守備範囲を明確にする

### design.ymlの`resilience`セクション

Spec作成時、Kiroは以下の項目を**必ず検討**してください：

#### 1. サーキットブレイカー（Circuit Breaker）

**検討すべき内容**:
- システムが継続的な接続を維持するか？
- 外部APIやデータベースへの接続があるか？
- 異常が連続した場合の対処は？

**判断基準**:
- **adopted**: デーモンモード、長時間実行、外部API連携がある場合
- **not-adopted**: 短命なCLI/バッチツール、単発実行の場合
- **delegated**: 上位システム（ジョブスケジューラ等）で実装すべき場合

**記載例**:
```yaml
resilience:
  circuit-breaker:
    considered: true
    decision: "not-adopted"
    rationale: |
      Komonは短命なCLI/バッチツールであり、継続的な接続維持や
      大量トラフィックを扱わない。サーキットブレイカーが必要となる
      ケースは、Komonの呼び出し元（ジョブスケジューラ、
      監視システム等）で実装する方が責務の分離として適切。
    delegated-to: "upstream-system"
    future-notes: |
      将来Komonがデーモンモードを持つ場合は、
      サーキットブレイカー設計を再検討する必要がある。
```

#### 2. 通知スパム防止（Notification Throttling）

**検討すべき内容**:
- 通知機能があるか？
- 同じ警告が短時間に連発する可能性は？
- ユーザー体験への影響は？

**判断基準**:
- **adopted**: 通知機能があり、連発の可能性がある場合
- **not-adopted**: 通知機能がない、または連発しない設計の場合

**記載例**:
```yaml
  notification-throttling:
    considered: true
    decision: "adopted"
    rationale: |
      同じ警告が短時間に連発する場合、通知スパムを防ぐため
      一時的に通知を抑制する。
    implementation:
      - "同じ警告が10回/3分以上 → 3分間通知停止"
      - "停止中も内部ログには記録"
      - "停止解除時に「通知を再開しました」メッセージ"
```

#### 3. Baseline自動リセット

**検討すべき内容**:
- baselineを使用する機能か？
- 異常が連発した場合、baselineがズレる可能性は？
- 自動リセットの判断基準は？

**判断基準**:
- **adopted**: baseline使用機能で、異常連発時のズレ対策が必要な場合
- **not-applicable**: baselineを使用しない機能の場合
- **not-adopted**: baseline使用だが、手動リセットで十分な場合

**記載例**:
```yaml
  baseline-reset:
    considered: true
    decision: "not-applicable"
    rationale: |
      この機能はbaselineを使用しないため、
      baseline自動リセット機能は不要。
    implementation: []
```

#### 4. その他のレジリエンス要素

**検討すべき内容**:
- データ欠損時のフォールバック
- 異常値の除外
- タイムアウト処理
- リトライ戦略
- エラー時の部分的な処理継続

**記載例**:
```yaml
  other-considerations:
    - consideration: "データ欠損時のフォールバック"
      decision: "adopted"
      rationale: |
        7日分のデータが不足している場合でも、利用可能なデータで
        予測を実行する。最低2日分のデータがあれば予測可能。
    - consideration: "異常値の除外"
      decision: "not-adopted"
      rationale: |
        v1.X.Xでは異常値の自動除外は実装しない。
        ユーザーが手動でデータを確認・修正することを想定。
        将来のバージョンで検討。
```

### Kiroへの指示

#### Spec作成時のチェックリスト

design.yml作成時、Kiroは以下を確認してください：

- [ ] `resilience`セクションを追加した
- [ ] サーキットブレイカーを検討した（adopted/not-adopted/delegated）
- [ ] 通知スパム防止を検討した（該当する場合）
- [ ] baseline自動リセットを検討した（該当する場合）
- [ ] その他のレジリエンス要素を検討した
- [ ] 各項目に`rationale`（理由）を記載した
- [ ] 採用した項目には`implementation`を記載した

#### 実装開始前の確認

実装開始前、Kiroは以下を確認してください：

- [ ] design.ymlの`resilience`セクションが存在する
- [ ] 全ての項目が検討されている（`considered: true`）
- [ ] 採用した項目の実装方針が明確である

### 効果

この検討プロセスにより：

1. **設計の完全性**: 検討漏れを防ぐ
2. **説明責任**: 将来の自分や他の開発者への説明が可能
3. **守備範囲の明確化**: システムの責務が明確になる
4. **将来の拡張性**: 再検討すべきタイミングが分かる

## まとめ

- **ローカル検証**: 開発品質を作り込む（Kiroが自動実行）
- **CI/CD検証**: 公開品質を証明する（GitHub Actionsが自動実行）
- **冗長性**: 気にしない（軽量なので問題なし）
- **警告の扱い**: トレーサビリティ系は必須、推奨事項は柔軟に
- **実行タイミング**: Spec完成時 + 実装開始直前
- **レジリエンス設計**: 必ず検討し、採用/非採用を明文化する

このルールにより、Spec品質が高く保たれ、実装の手戻りが減少します。