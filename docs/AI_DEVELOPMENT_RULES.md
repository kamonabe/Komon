# AI開発ルール

## はじめに

このドキュメントは、Komonプロジェクトで採用している**AI支援開発（Kiro IDE）**の運用ルールを記録します。

**目的**:
- AI開発のベストプラクティスを明文化
- 「理解に追いつける範囲で進める」原則の共有
- 他のプロジェクトでも再現可能にする

---

## 基本原則

### 最優先原則：「理解に追いつける範囲で進める」

```
人間の理解速度 > AI の生成速度
```

この原則を守ることで：
- ✅ コードの品質が保たれる
- ✅ 属人化を防げる
- ✅ 長期的なメンテナンス性が保たれる
- ✅ バグの早期発見が可能
- ✅ セキュリティリスクを低減

### なぜこの原則が重要か

**AIは速いが、理解は人間にしかできない**:
- AIは1分で100行のコードを生成できる
- でも、人間が理解するには10分かかる
- 理解せずに進めると、後で大きな問題になる

**実例**:
```
❌ 悪い例：
AIが新機能を一気に実装 → 理解できないまま進める
→ バグが混入 → 後で修正に3倍の時間がかかる

✅ 良い例：
AIが小さく実装 → 理解して確認 → 次の小さな実装
→ バグを早期発見 → 修正が簡単
```

---

## AI成果物のチェックポイント

### 自動で進めて良いもの（小さい粒度）

**条件**:
- 変更が10行以内
- 影響範囲が1ファイル以内
- テストで検証可能
- ロールバックが容易

**例**:
- ✅ タイポ修正（`psutl` → `psutil`）
- ✅ インポート追加（`import os`）
- ✅ 型ヒント追加（`def func(x: int) -> str:`）
- ✅ ドキュメント更新（docstring追加）
- ✅ テストケース追加（既存機能のテスト）

**判断基準**:
```python
if (
    lines_changed <= 10 and
    files_affected == 1 and
    all_tests_pass and
    easy_to_rollback
):
    # 自動で進めてOK
    proceed_automatically()
```

### 人間の確認が必要なもの（中程度の粒度）

**条件**:
- 変更が10〜50行
- 影響範囲が2〜3ファイル
- 既存機能への影響が小さい
- テストで検証可能

**例**:
- ⚠️ 新規関数の追加
- ⚠️ 既存関数の変更（ロジック修正）
- ⚠️ 設定ファイルの変更
- ⚠️ 依存パッケージの追加
- ⚠️ テスト戦略の変更

**判断基準**:
```python
if (
    10 < lines_changed <= 50 and
    2 <= files_affected <= 3 and
    small_impact_on_existing_features
):
    # 人間の確認が必要
    request_human_review()
```

### 必ず人間が理解してから進めるもの（大きい粒度）

**条件**:
- 変更が50行以上
- 影響範囲が4ファイル以上
- 既存機能への影響が大きい
- アーキテクチャに関わる

**例**:
- ❌ 新規モジュールの追加
- ❌ アーキテクチャの変更
- ❌ 既存機能への影響が大きい変更
- ❌ セキュリティに関わる変更
- ❌ データベーススキーマの変更

**判断基準**:
```python
if (
    lines_changed > 50 or
    files_affected >= 4 or
    large_impact_on_existing_features or
    security_related
):
    # 必ず人間が理解してから進める
    stop_and_explain_to_human()
```

---

## 粒度の判断基準

### 小さい粒度の条件

| 項目 | 基準 |
|------|------|
| 変更行数 | 10行以内 |
| 影響ファイル数 | 1ファイル |
| 既存機能への影響 | なし |
| テスト | 既存テストで検証可能 |
| ロールバック | 容易（git revert 1回） |
| 理解時間 | 1分以内 |

**例**:
```python
# タイポ修正（1行、1ファイル、影響なし）
- import psutl
+ import psutil
```

### 中程度の粒度の条件

| 項目 | 基準 |
|------|------|
| 変更行数 | 10〜50行 |
| 影響ファイル数 | 2〜3ファイル |
| 既存機能への影響 | 小さい |
| テスト | 新規テストが必要 |
| ロールバック | 可能（git revert 数回） |
| 理解時間 | 5〜10分 |

**例**:
```python
# 新規関数の追加（30行、2ファイル、影響小）
# src/komon/new_feature.py: 新規関数
# tests/test_new_feature.py: テスト追加
```

### 大きい粒度の条件

| 項目 | 基準 |
|------|------|
| 変更行数 | 50行以上 |
| 影響ファイル数 | 4ファイル以上 |
| 既存機能への影響 | 大きい |
| テスト | 大規模なテスト追加 |
| ロールバック | 困難 |
| 理解時間 | 30分以上 |

**例**:
```python
# 新規モジュールの追加（200行、5ファイル、影響大）
# src/komon/new_module.py: 新規モジュール
# src/komon/analyzer.py: 既存モジュール変更
# tests/test_new_module_*.py: テスト追加（3ファイル）
```

---

## 人間レビューの境界線

### 自動で進めて良い条件

**全ての条件を満たす場合のみ**:
- ✅ 全テストがパス
- ✅ カバレッジが維持または向上
- ✅ 既存機能への影響がない
- ✅ ロールバックが容易
- ✅ セキュリティリスクがない
- ✅ 変更内容が明確

**判断フロー**:
```
1. 全テストがパス？
   NO → 人間レビュー必須
   YES → 次へ

2. カバレッジが維持？
   NO → 人間レビュー必須
   YES → 次へ

3. 既存機能への影響？
   YES → 人間レビュー必須
   NO → 次へ

4. ロールバックが容易？
   NO → 人間レビュー必須
   YES → 自動で進めてOK
```

### 人間レビューが必須な条件

**いずれかに該当する場合**:
- ❌ テストが失敗する
- ❌ カバレッジが低下する
- ❌ 既存機能への影響がある
- ❌ セキュリティに関わる
- ❌ ロールバックが困難
- ❌ 変更内容が不明確

**対応**:
1. AIに説明を求める
2. 変更内容を理解する
3. 問題がないか確認する
4. 承認または却下を判断

---

## 実装時の注意点

### 段階的に進める

**原則**:
```
小さく実装 → テスト → 確認 → 次の小さな実装
```

**悪い例**:
```
❌ 一気に全機能を実装 → テスト → 大量のエラー → 修正に時間がかかる
```

**良い例**:
```
✅ 関数1を実装 → テスト → OK
✅ 関数2を実装 → テスト → OK
✅ 統合 → テスト → OK
```

### いつでも中断・再開できるように

**タスクを小さく分割**:
```markdown
# 悪い例
- [ ] 新機能を実装（大きすぎる）

# 良い例
- [ ] 1. モジュール作成
- [ ] 2. 関数1実装
- [ ] 3. 関数2実装
- [ ] 4. テスト追加
- [ ] 5. ドキュメント更新
```

**各タスクで完結させる**:
- 各タスク完了時にコミット
- 各タスク完了時にテスト実行
- 各タスク完了時に動作確認

**コミットを細かく**:
```bash
# 悪い例
git commit -m "新機能実装"  # 200行の変更

# 良い例
git commit -m "feat: モジュール作成"  # 30行
git commit -m "feat: 関数1実装"  # 20行
git commit -m "test: テスト追加"  # 15行
```

### 理解できない部分は止まる

**AIの提案を盲目的に受け入れない**:
```
AI: 「この関数を追加してください」

人間: 「なぜこの関数が必要？」
      「どういう仕組み？」
      「他の方法はない？」

→ 理解できるまで質問する
→ 理解できたら実装
→ 理解できなければ別の方法を検討
```

**理解できない時の対応**:
1. AIに説明を求める
2. ドキュメントを読む
3. 小さく試してみる
4. 別の方法を検討する
5. 一旦保留して後で考える

---

## Komonでの実践例

### 成功例：段階的通知メッセージ（TASK-001）

**実装方針**:
1. 小さく分割（6サブタスク）
2. 各サブタスク完了時にテスト
3. 理解しながら進める

**実装フロー**:
```
✅ サブタスク1: モジュール作成（30行）
   → テスト → OK → 理解 → 次へ

✅ サブタスク2: 通知履歴連携（20行）
   → テスト → OK → 理解 → 次へ

✅ サブタスク3: メッセージテンプレート（40行）
   → テスト → OK → 理解 → 次へ

✅ サブタスク4: 設定ファイル拡張（10行）
   → テスト → OK → 理解 → 次へ

✅ サブタスク5: テスト追加（50行）
   → テスト → OK → 理解 → 次へ

✅ サブタスク6: ドキュメント更新（20行）
   → テスト → OK → 完了
```

**結果**:
- 全268テストがパス
- カバレッジ93%維持
- バグなし
- 実装時間: 約2時間

### 失敗例：一気に実装しようとした場合（仮想）

**もし一気に実装していたら**:
```
❌ 全機能を一気に実装（170行）
   → テスト → 10件失敗
   → 原因特定に時間がかかる
   → 修正 → また別のエラー
   → 結局3倍の時間がかかる
```

**教訓**:
- 小さく分割することの重要性
- 理解しながら進めることの価値
- テストを細かく実行することの効果

---

## AI開発の落とし穴

### 落とし穴1: 理解せずに進める

**症状**:
- AIが生成したコードをそのままコピペ
- 動いているから問題ないと思い込む
- 後でバグが見つかる

**対策**:
- 必ず理解してから進める
- 理解できない部分は質問する
- 小さく試してみる

### 落とし穴2: 大きすぎる粒度

**症状**:
- 一気に大量のコードを生成
- テストが大量に失敗
- 修正に時間がかかる

**対策**:
- タスクを小さく分割
- 各タスクでテスト
- 段階的に進める

### 落とし穴3: テストを後回し

**症状**:
- 実装を優先してテストを後回し
- 後でテストを書くのが大変
- バグが見つかりにくい

**対策**:
- 実装とテストを同時に進める
- 各サブタスクでテスト追加
- TDD（テスト駆動開発）を意識

### 落とし穴4: AIへの過度な依存

**症状**:
- AIがないと何もできない
- 自分で考えなくなる
- 属人化（AI依存）

**対策**:
- AIは「補助」として使う
- 自分で考える習慣を維持
- AIの提案を批判的に評価

---

## まとめ

### AI開発の3原則

1. **理解に追いつける範囲で進める**
   - 人間の理解速度 > AI の生成速度

2. **小さく分割して段階的に**
   - 小さく実装 → テスト → 確認 → 次へ

3. **理解できない部分は止まる**
   - AIの提案を盲目的に受け入れない

### Komonでの実践結果

- ✅ 22バージョンリリース（v1.0.0 → v1.22.0）
- ✅ 385テスト、カバレッジ93%
- ✅ バグの早期発見
- ✅ 高い開発速度と品質の両立

### 他のプロジェクトへの応用

このルールは、Komon以外のプロジェクトでも応用可能です：

1. `.kiro/steering/ai-development-rules.md` を作成
2. プロジェクト固有のルールを追加
3. チームで共有
4. 継続的に改善

---

## 参考資料

### Komonの開発体制

- **Spec駆動開発**: requirements.yml → design.yml → tasks.yml
- **ステアリングルール**: 8種類のルールで品質保証
- **AI支援開発**: Kiro IDEとの協働
- **プロパティテスト**: hypothesis使用で不変条件を検証

### 関連ドキュメント

- `docs/CONTRIBUTING.md`: 貢献ガイド
- `.kiro/steering/development-workflow.md`: 開発ワークフロー
- `.kiro/steering/spec-quality-assurance.md`: Spec品質保証
- `.kiro/specs/development-improvements.md`: 開発基盤の改善案

---

## 更新履歴

- 2025-11-30: 初版作成
